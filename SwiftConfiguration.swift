#!/usr/bin/env xcrun --sdk macosx swift

struct Configuration {
    let name: String
    let contents: Dictionary<String, Any>

    var allKeys: Set<String> {
        return Set(contents.keys)
    }
}
import Foundation

struct ConfigurationError: LocalizedError {

    private let message: String

    init(message: String) {
        self.message = message
    }

    var errorDescription: String? {
        return message
    }
}

class ConfigurationManagerGenerator {

    // MARK: - Properties

    private let outputFilePath: String
    private let configurationKey: String

    // MARK: - Lifecycle

    init(outputFilePath: String, configurationKey: String) {
        self.outputFilePath = outputFilePath
        self.configurationKey = configurationKey
    }

    // MARK: - Methods

    func generateConfigurationManagerFile(for configurations: [Configuration]) throws {
        let template = ConfigurationManagerTemplate(configurations: configurations, configurationKey: configurationKey)
        try template.configurationManagerString.write(toFile: outputFilePath, atomically: true, encoding: .utf8)
    }
}

class ConfigurationManagerTemplate {

    private let configurationKey: String
    private let configurationsString: String
    private let configurationsKeysString: String

    lazy var configurationManagerString = #"""
    // This file is autogenerated. Do not modify!

    import Foundation

    class ConfigurationManager {

        enum Configuration: String {
            \#(configurationsString)
        }

        enum ConfigurationKey: String {
            \#(configurationsKeysString)
        }

        // MARK: Shared instance

        static let shared = ConfigurationManager()

        // MARK: Properties

        private let configurationKey = "\#(configurationKey)"
        private let configurationDictionaryName = "Configuration"

        let activeConfiguration: Configuration
        private let activeConfigurationDictionary: NSDictionary

        // MARK: Lifecycle

        init () {
            let bundle = Bundle(for: ConfigurationManager.self)
            guard let rawConfiguration = bundle.object(forInfoDictionaryKey: configurationKey) as? String,
                let activeConfiguration = Configuration(rawValue: rawConfiguration),
                let configurationDictionaryPath = bundle.path(forResource: configurationDictionaryName, ofType: "plist"),
                let configurationDictionary = NSDictionary(contentsOfFile: configurationDictionaryPath),
                let activeEnvironmentDictionary = configurationDictionary[activeConfiguration.rawValue] as? NSDictionary
                else {
                    fatalError("Configuration Error")

            }
            self.activeConfiguration = activeConfiguration
            self.activeConfigurationDictionary = activeEnvironmentDictionary
        }

        // MARK: Methods

        func value(for key: ConfigurationKey) -> String {
            guard let value = activeConfigurationDictionary[key.rawValue] as? String else {
                fatalError("No value satysfying requirements")
            }
            return value
        }

        func isRunning(in configuration: Configuration) -> Bool {
            return activeConfiguration == configuration
        }
    }
    """#

    init(configurations: [Configuration], configurationKey: String) {
        var configurationsString = ""
        var configurationsKeysString = ""
        var allKeys = Set<String>()
        for configuration in configurations {
            configurationsString += "case \(configuration.name)\n\t\t"
            allKeys = allKeys.union(configuration.allKeys)
        }
        for key in allKeys {
            configurationsKeysString += "case \(key)\n\t\t"
        }
        self.configurationsString = configurationsString
        self.configurationsKeysString = configurationsKeysString
        self.configurationKey = configurationKey
    }
}
import Foundation

class ConfigurationProvider {

    // MARK: - Properties

    private let configurationPlistPath: String

    // MARK: - Lifecycle

    init(configurationPlistPath: String) {
        self.configurationPlistPath = configurationPlistPath
    }

    // MARK: Methods

    func getConfigurations() throws -> [Configuration] {
        guard let configurationsDictionary = NSDictionary(contentsOfFile: configurationPlistPath) else {
            throw ConfigurationError(message: "Could not load configuration dictionary at: \(configurationPlistPath)")
        }

        return try configurationsDictionary.map { configurationDictionary -> Configuration in
            print(configurationDictionary)
            guard let name = configurationDictionary.key as? String, let contents = configurationDictionary.value as? Dictionary<String, Any> else {
                throw ConfigurationError(message: "The configuration file has invalid format. Please consult the docs.")
            }

            return Configuration(name: name, contents: contents)
        }
    }
}

class ConfigurationValidator {

    // MARK: - Properties

    private let activeEnvironmentName: String

    // MARK: - Lifecycle

    init(activeEnvironmentName: String) {
        self.activeEnvironmentName = activeEnvironmentName
    }

    // MARK: - Public Methods

    func validateConfigurations(_ configurations: [Configuration]) throws {
        let allKeys = configurations.reduce(Set<String>(), { (result, configuration) -> Set<String> in
                return result.union(configuration.allKeys)
            })
        for configuration in configurations {
            let difference = allKeys.subtracting(configuration.allKeys)
            if !difference.isEmpty {
                var warning = ""
                for key in difference {
                    warning += "warning: missing key: \(key) in configuration: \(configuration.name)"
                }
                throw ConfigurationError(message: warning)
            }
        }

        let configurationNames = configurations.map({$0.name})

        guard configurationNames.contains(where: {[weak self] in $0 == self?.activeEnvironmentName}) else {
            throw ConfigurationError(message: "error: The configuration file does not contain a configuration for the active configuration (\(activeEnvironmentName))")
        }
    }
}

import Foundation

class PlistModifier {

    // MARK: - Properties

    private let plistFilePath: String
    private let configurationKey: String
    private let configurationValue = "$(CONFIGURATION)"
    private let plistBuddyPath = "/usr/libexec/PlistBuddy"

    // MARK: - Lifecycle

    init(plistFilePath: String, configurationKey: String) {
        self.plistFilePath = plistFilePath
        self.configurationKey = configurationKey
    }

    // MARK: - Methods

    func addOrSetConfigurationKey() throws {
        if invokeShell(with: plistBuddyPath, "-c", "Add :\(configurationKey) string \(configurationValue)", "\(plistFilePath)") != 0 {
            guard invokeShell(with: plistBuddyPath, "-c", "Set :\(configurationKey) \(configurationValue)", "\(plistFilePath)") == 0 else {
                throw ConfigurationError(message: "Could not modify InfoPlist file")
            }
        }
    }

    private func invokeShell(with args: String...) -> Int32 {
        let task = Process()
        task.launchPath = "/usr/bin/env"
        task.arguments = args
        task.launch()
        task.waitUntilExit()
        return task.terminationStatus
    }
}
import Foundation

print(CommandLine.arguments)
private let configurationKey = "Configuration"
private let plistFilePath = CommandLine.arguments[1]
private let configurationPlistPath = CommandLine.arguments[2]
private let outputFilePath = CommandLine.arguments[3]
private let activeEnvironmentName = CommandLine.arguments[4]

let infoPlistModifier = PlistModifier(plistFilePath: plistFilePath, configurationKey: configurationKey)
let configurationProvider = ConfigurationProvider(configurationPlistPath: configurationPlistPath)
let configurationValidator = ConfigurationValidator(activeEnvironmentName: activeEnvironmentName)
let configurationManagerGenerator = ConfigurationManagerGenerator(outputFilePath: outputFilePath, configurationKey: configurationKey)

do {
    let configurations = try configurationProvider.getConfigurations()
    try configurationValidator.validateConfigurations(configurations)
    try configurationManagerGenerator.generateConfigurationManagerFile(for: configurations)
    try infoPlistModifier.addOrSetConfigurationKey()
    exit(0)
} catch {
    print(error.localizedDescription)
    exit(1)
}
