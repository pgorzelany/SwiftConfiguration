#!/usr/bin/env xcrun --sdk macosx swift
import Foundation

struct ParsedArguments {
    let plistFileUrl: URL
    let configurationPlistFileUrl: URL
    let outputFileUrl: URL
    let activeEnvironmentName: String
}

class ArgumentsParser {
    func parseArguments(_ arguments: [String]) throws -> ParsedArguments {
        print("parsing arguments")
        guard arguments.count == 5 else {
            throw ConfigurationError(message: "Insufficient number of arguments provided. Refer to the docs.")
        }

        guard let plistFileUrl = URL(string: arguments[1]) else {
            throw ConfigurationError(message: "\(arguments[1]) is not a valid URL")
        }

        guard let configurationPlistFileUrl = URL(string: arguments[2]) else {
            throw ConfigurationError(message: "\(arguments[2]) is not a valid URL")
        }

        guard let outputFileUrl = URL(string: arguments[3]) else {
            throw ConfigurationError(message: "\(arguments[3]) is not a valid URL")
        }

        return ParsedArguments(plistFileUrl: plistFileUrl,
                               configurationPlistFileUrl: configurationPlistFileUrl,
                               outputFileUrl: outputFileUrl,
                               activeEnvironmentName: CommandLine.arguments[4])
    }
}

struct Configuration {
    let name: String
    let contents: Dictionary<String, Any>

    var allKeys: Set<String> {
        return Set(contents.keys)
    }
}

struct ConfigurationError: LocalizedError {

    private let message: String

    init(message: String) {
        self.message = message
    }

    var errorDescription: String? {
        return message
    }
}

class ConfigurationManagerGenerator {

    // MARK: - Properties

    private let outputFileUrl: URL
    private let configurationKey: String

    // MARK: - Lifecycle

    init(outputFileUrl: URL, configurationKey: String) {
        self.outputFileUrl = outputFileUrl
        self.configurationKey = configurationKey
    }

    // MARK: - Methods

    func generateConfigurationManagerFile(for configurations: [Configuration]) throws {
        let template = ConfigurationManagerTemplate(configurations: configurations, configurationKey: configurationKey)
        try template.configurationManagerString.write(to: outputFileUrl, atomically: true, encoding: .utf8)
    }
}

class ConfigurationManagerTemplate {

    private let configurationKey: String
    private let configurationsString: String
    private let configurationsKeysString: String

    lazy var configurationManagerString = #"""
    // This file is autogenerated. Do not modify!

    import Foundation

    class ConfigurationManager {

        enum Configuration: String {
            \#(configurationsString)
        }

        enum ConfigurationKey: String {
            \#(configurationsKeysString)
        }

        // MARK: Shared instance

        static let shared = ConfigurationManager()

        // MARK: Properties

        private let configurationKey = "\#(configurationKey)"
        private let configurationDictionaryName = "Configuration"

        let activeConfiguration: Configuration
        private let activeConfigurationDictionary: NSDictionary

        // MARK: Lifecycle

        init () {
            let bundle = Bundle(for: ConfigurationManager.self)
            guard let rawConfiguration = bundle.object(forInfoDictionaryKey: configurationKey) as? String,
                let activeConfiguration = Configuration(rawValue: rawConfiguration),
                let configurationDictionaryPath = bundle.path(forResource: configurationDictionaryName, ofType: "plist"),
                let configurationDictionary = NSDictionary(contentsOfFile: configurationDictionaryPath),
                let activeEnvironmentDictionary = configurationDictionary[activeConfiguration.rawValue] as? NSDictionary
                else {
                    fatalError("Configuration Error")

            }
            self.activeConfiguration = activeConfiguration
            self.activeConfigurationDictionary = activeEnvironmentDictionary
        }

        // MARK: Methods

        func value(for key: ConfigurationKey) -> String {
            guard let value = activeConfigurationDictionary[key.rawValue] as? String else {
                fatalError("No value satysfying requirements")
            }
            return value
        }

        func isRunning(in configuration: Configuration) -> Bool {
            return activeConfiguration == configuration
        }
    }
    """#

    init(configurations: [Configuration], configurationKey: String) {
        var configurationsString = ""
        var configurationsKeysString = ""
        var allKeys = Set<String>()
        for configuration in configurations {
            configurationsString += "case \(configuration.name)\n\t\t"
            allKeys = allKeys.union(configuration.allKeys)
        }
        for key in allKeys {
            configurationsKeysString += "case \(key)\n\t\t"
        }
        self.configurationsString = configurationsString
        self.configurationsKeysString = configurationsKeysString
        self.configurationKey = configurationKey
    }
}

class ConfigurationProvider {

    // MARK: Methods

    func getConfigurations(at configurationPlistFileUrl: URL) throws -> [Configuration] {
        guard let configurationsDictionary = NSDictionary(contentsOf: configurationPlistFileUrl) else {
            throw ConfigurationError(message: "Could not load configuration dictionary at: \(configurationPlistFileUrl)")
        }

        return try configurationsDictionary.map { configurationDictionary -> Configuration in
            print(configurationDictionary)
            guard let name = configurationDictionary.key as? String, let contents = configurationDictionary.value as? Dictionary<String, Any> else {
                throw ConfigurationError(message: "The configuration file has invalid format. Please refer to the docs.")
            }

            return Configuration(name: name, contents: contents)
        }
    }
}

class ConfigurationValidator {

    // MARK: - Public Methods

    func validateConfigurations(_ configurations: [Configuration], activeEnvironmentName: String) throws {
        let allKeys = configurations.reduce(Set<String>(), { (result, configuration) -> Set<String> in
                return result.union(configuration.allKeys)
            })
        for configuration in configurations {
            let difference = allKeys.subtracting(configuration.allKeys)
            if !difference.isEmpty {
                var warning = ""
                for key in difference {
                    warning += "Missing key: \(key) in configuration: \(configuration.name)\n"
                }
                throw ConfigurationError(message: warning)
            }
        }

        let configurationNames = configurations.map({$0.name})

        guard configurationNames.contains(where: {$0 == activeEnvironmentName}) else {
            throw ConfigurationError(message: "The configuration file does not contain a configuration for the active configuration (\(activeEnvironmentName))")
        }
    }
}

class MessagePrinter {
    /// The warning will show up in compiler build time warnings
    func printWarning(_ items: Any...) {
        for item in items {
            print("warning: \(item)")
        }
    }

    /// The error will show up in compiler build time errors
    func printError(_ items: Any...) {
        for item in items {
            print("error: \(item)")
        }
    }
}

/// Modifies the plist file by adding the configuration key
/// The value indicates the current runtime configuration
class PlistModifier {

    // MARK: - Properties

    private let plistFileUrl: URL
    private let configurationKey: String
    private let configurationValue = "$(CONFIGURATION)"
    private let plistBuddyPath = "/usr/libexec/PlistBuddy"

    // MARK: - Lifecycle

    init(plistFileUrl: URL, configurationKey: String) {
        self.plistFileUrl = plistFileUrl
        self.configurationKey = configurationKey
    }

    // MARK: - Methods

    func addOrSetConfigurationKey() throws {
        if invokeShell(with: plistBuddyPath, "-c", "Add :\(configurationKey) string \(configurationValue)", "\(plistFileUrl.path)") != 0 {
            guard invokeShell(with: plistBuddyPath, "-c", "Set :\(configurationKey) \(configurationValue)", "\(plistFileUrl.path)") == 0 else {
                throw ConfigurationError(message: "Could not modify InfoPlist file")
            }
        }
    }

    private func invokeShell(with args: String...) -> Int32 {
        let task = Process()
        task.launchPath = "/usr/bin/env"
        task.arguments = args
        task.launch()
        task.waitUntilExit()
        return task.terminationStatus
    }
}

print(CommandLine.arguments)
private let printer = MessagePrinter()
private let argumentsParser = ArgumentsParser()
private let configurationKey = "Configuration"

do {
    let arguments = try argumentsParser.parseArguments(CommandLine.arguments)
    let infoPlistModifier = PlistModifier(plistFileUrl: arguments.plistFileUrl, configurationKey: configurationKey)
    let configurationProvider = ConfigurationProvider()
    let configurationValidator = ConfigurationValidator()
    let configurationManagerGenerator = ConfigurationManagerGenerator(outputFileUrl: arguments.outputFileUrl, configurationKey: configurationKey)
    let configurations = try configurationProvider.getConfigurations(at: arguments.configurationPlistFileUrl)
    try configurationValidator.validateConfigurations(configurations, activeEnvironmentName: arguments.activeEnvironmentName)
    try infoPlistModifier.addOrSetConfigurationKey()
    try configurationManagerGenerator.generateConfigurationManagerFile(for: configurations)
    exit(0)
} catch {
    printer.printWarning(error.localizedDescription)
    exit(0)
}
